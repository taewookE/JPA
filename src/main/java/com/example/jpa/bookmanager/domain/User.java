package com.example.jpa.bookmanager.domain;

import com.example.jpa.bookmanager.domain.listener.UserEntityListener;
import lombok.*;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

//JPA
@NoArgsConstructor
@RequiredArgsConstructor
@AllArgsConstructor
@Data
@Builder
@Entity
//@EntityListeners(value = {MyEntityListener.class , UserEntityListener.class})
//@EntityListeners(value = {AuditingEntityListener.class , UserEntityListener.class}))
@EntityListeners(value = {UserEntityListener.class})
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
/*TODO: @Table에 제약조건과 index를 걸 수 있으나
        실제 DB의 index가 걸려있지 않으면 소용이 없음.
        일반적으로 실제 DB에서 설정하고 JPA Entity에는 아래와 같이 표기하지 않는것이 일반적임.
.*/
@Table(name = "user", indexes = {@Index(columnList = "name")}, uniqueConstraints = {@UniqueConstraint(columnNames = {"email"})})
/*
테이블 명을 셋팅하면 아래와 같이 테이블이 생성됨.
* Hibernate:

    create table user_legacy (
       id bigint generated by default as identity,
        created_at timestamp,
        email varchar(255),
        name varchar(255),
        updated_at timestamp,
        primary key (id)
    )
*
* */
public class User extends BaseEntity {
    /*TODO: GenerationType 확인
    *  1. Identity ( MySQL , Maria DB에서 많이사용하는 방법 , DB autoIncrement 값을 활용. Transaction 종료전 ID값을 가져옴. Transaction이 실패해도 ID값이 증가함.)
    *  2. Sequence ( Oracle, PostgreSQL에서 사용 )
    *  3. TABLE : 별도 테이블에서 ID값을 가져옴
    *  4. AUTO : 각 DB에 적합한 값을 자동으로 설정해줌 ( default 값임 )
    *  보통은 구체적인 값을 셋팅 해줌.
    * */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NonNull
//    @Column(unique = true) , 단독 unique설정
    private String name;

    @NonNull
    private String email;

    /*TODO: JPA에는 persist 전에는 해당 값이 null이라 nullPointException이 발생할수도 있어 기본적인 생성자를 만들어주는 것이 좋다.
    *       일반적인 경우에는 빈 리스트로 return을 해주긴해서 문제는 없긴하다.
    * JoinColumn을 sneakCase로 사용하게 되면 아래와 같은 오류가 발생한다.
    * Caused by: org.hibernate.DuplicateMappingException: Table [user_history]
    * contains physical column name [user_id] referred to by multiple logical column names: [user_id], [userId]
    *
    *
    * 그리고 history의 경우는 변경되면 안되는 값(readonly)이므로, @JoinColumn내에서 insertable , updatable 자체를 false처리를 해주어야한다.
    *
    * JPA가 불필요한 query를 많이 실행하게 될수도 있다.
    * 테이블과 entity를 잘 설계해서 최적의 query를 실행시키도록 하는것이 JPA 고수로 가는 길이다.
    * */
    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id" ,insertable = false,updatable = false)
    @ToString.Exclude
    private List<UserHistory> userHistories = new ArrayList<>();


    @OneToMany
    @JoinColumn(name = "user_id")
    @ToString.Exclude
    private List<Review> Reviews = new ArrayList<>();


    /* name 속성은 실제 DB column명을 단축어를 쓴다던지의 상황에 맞추어서 사용하면 된다.
    *  nullable = false 는 not null column으로 DDL을 만들때 쓴다.
    *  테스트 목적으로 nullable = false를 쓰는 경우가 많다고 한다. 로직적으로 값이 존재유무 체크등 ??
    * */
//    @Column(name = "crtdat" ,nullable = false)
//    @Column(updatable = false)
//    @CreatedDate
//    private LocalDateTime createdAt;
//
////    @Column(insertable = false)
//    @LastModifiedDate
//    private LocalDateTime updatedAt;

    /*TODO: Transient의 경우는 영속성 처리에서 제외됨.
            DB데이터에 반영되지 않고 해당 객체와 생명주기를 같이함.
            updatable , insertable = false + select도 불가함.
            DB record에는 처리하지 않지만 객체에서는 활용하기 위해서 사용됨.
    */
//    @Transient
//    private String testData;

    //EnumType은 ORDINAL이 defualt임.
    //TODO: Enum을 사용할떄는 EnumType을 String으로 꼭 처리해야 나중에 Enum처리 시 이슈가 발생하지 않는다.
    //순서로 셋팅하게 되면 Enum의 순서가 바뀌면 DB가 꼬이는 문제가 발생된다.
    @Enumerated(value = EnumType.STRING)
    private Gender gender;

    /*TODO :테이블내 동일 컬럼이 선언되게 되므로 (Address) AttributeOverride를 활용 한다.
    *       detail의 경우는 아래 이름으로 재정의 된다. (최종 home_address_detail)
    *
    * */
    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name ="city" , column = @Column(name = "home_city")),
            @AttributeOverride(name ="district", column = @Column(name = "home_district")),
            @AttributeOverride(name ="detail" , column = @Column(name = "home_address_detail")),
            @AttributeOverride(name ="zipCode" , column = @Column(name = "home_zipCode"))
    })
    private Address homeAddress;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name ="city" , column = @Column(name = "company_city")),
            @AttributeOverride(name ="district", column = @Column(name = "company_district")),
            @AttributeOverride(name ="detail" , column = @Column(name = "company_address_detail")),
            @AttributeOverride(name ="zipCode" , column = @Column(name = "company_zipCode"))
    })
    private Address companyAddress;


//    //TODO: 향후 relation에서 좀더 확인해볼것.
//    @OneToMany(fetch = FetchType.EAGER)
//    private List<Address> address;


//    @PrePersist
//    @PreUpdate
//    @PreRemove
//    @PostPersist
//    @PostUpdate
//    @PostRemove
//    @PostLoad
    /*TODO : 반복적으로 셋팅될 값을 EntityEvent Listener를 통해서 셋팅하면 실수를 줄여 줄 수 있다.*/
//    @PrePersist
//    public void prePersist(){
//        System.out.println(">>> prePersist");
//        this.createdAt = LocalDateTime.now();
//        this.updatedAt = LocalDateTime.now();
//    }
//    @PostPersist
//    public void postPersist(){
//        System.out.println(">>> postPersist");
//    }
//    @PreUpdate
//    public void preUpdate(){
//        System.out.println(">>> preUpdate");
//        this.updatedAt = LocalDateTime.now();
//    }
//    @PreRemove
//    public void preRemove(){
//        System.out.println(">>> preRemove");
//    }
//    @PostRemove
//    public void postRemove(){
//        System.out.println(">>> postRemove");
//    }
//    @PostLoad
//    public void postLoad(){
//        System.out.println(">>> postLoad");
//    }
}
